#include<bits/stdc++.h>

using namespace std;

class Graph{
	int V;
	list<int> *l;
public:
	Graph(int V){
		this->V = V;
		l = new list<int>[V];
	}

	void addEdge(int a,int b,bool undir=false){
		l[a].push_back(b);
		if(undir){
			l[b].push_back(a);
		}
	}
// Imitating the DFS algorithm is very easy.
	void dfsHelper(int node,bool *visited){
		// Here we are passing the dfs helper function as it should not be created over and over again.
		visited[node]=true;
		cout<<node<<" ";
		// make dfs call to all its neighbour
		for(int nbr:l[node]){
			// here we will be checking whether the neighbours of the current ndoe are visited or not.
			if(!visited[nbr]){
				dfsHelper(nbr,visited);
			}
		}
	}
	// Here the output which is being generated by the dfs algorithm can be different according to the data which has been inserted to the graph. The order of the insertion of the elements is very important.
	void dfs(int source){
		bool *visited = new bool[V]{0};
		dfsHelper(source,visited);
	}
};

int main()
{
	// This basically means that we have created a particular graph and then we are starting the dfs from the first node that is present.
		Graph g(7);
		g.addEdge(0,1);
		g.addEdge(1,2);
		g.addEdge(2,3);
		g.addEdge(3,5);
		g.addEdge(5,6);
		g.addEdge(4,5);
		g.addEdge(0,4);
		g.addEdge(3,4);
		g.dfs(1);
}