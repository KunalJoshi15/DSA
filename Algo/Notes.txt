Finding the digits of the number there 
are two good ways of doing it we can use the division method.

int countDigit(long n)
{
    int count=0;
    while(n>=0)
    {
        n=n/10;
        ++count;
    }
    return count;
}
Recursive Solution
int countDigits(long n)
{
    if(n==0)
        return 0;
    return 1+countDigits(n/10);
}
Logarathmic Solution
int countDigits(long n)
{
    return floor(log10(n)+1);
}
The complexity in case of the Logarathmic solution is O(1).

There the basic of the mathematics will be used as per our need.

For finding out whether a particular number which is being provided to us is palindrome or not we can use the concept of 
finding the reversal of the number if that reversed number is equal to the actual number then we can say that the number is palindrome
while in the second case the number is not palindrome.

For finding the GCD of a particular number we use the naive solution for that particular. We consider all the number which are smaller then the current number 
if any of the smaller numbers divide the number then we increase the count.
The first recursive call basically swaps the two numbers from one location to another.

LCM of two numbers
I/P: a=4,b=6
OP: 12
This will be finding the least number which will be divisible by both the numbers.
1 is a number which is neither prime and nor composite.

Check whether the number is prime or not. 
if(n==2||n==3) return true;
The number is definitely not prime.
Otherwise we can directly check.
if(n%2==0)
    return 

We can create an algorithm that can help us in fetching the prime numbers.
We can find the factors
The current method we will write most of the base cases that we have if n==1
we return a false value;
n==2 || n==3 return true
n%2==0||n%3 ==0
return false;
Here we are directly omiting all the values which are even and there are many numbers which are the factor of there
Now implement our own solution in which we run a loop O(root(n)) times and incrementation is done i=i+6;
if(n%i==0||n%(i+2)==0)
 returnn false;

We will consider all the prime factors which are within a range.
The naive solution that comes to the mind for finding the divisors of the particular number is 
firstly consider all the numbers 
from i=2 i*i<=n;i++{

}
if(isPrime(i))
{
    int x=i;
    while(n%x==0)
    {
        print x;
        x=x*i;
    }
}
(Will print all the prime factors which are possible.)
The better solution to this particular approach would be finding the first prime factor and t
This solution does not require any extra space. The complexity is root(n)

Seive of erasthanoes is the way for finding whether the number are prime or not.
This algorithm only keeps the number which are actually prime as true while all the other values are marked as false.
(Initially all the indices have the values as true)-> after the algorithm does its work. only elements that have 
We mark the multiples of 2,3,5
We are considering only the prime factors of the current number.

To find the power in the solution we need an elegant way. Uses the power of recursion
if the number is 0 then nothing much to be done.

Bitwise operations are performed on the individual bits itself.
Bitwise AND does the bitwise AND of the two numbers while the Bitwise OR does the bitwise OR of the two numbers.
Bitwise arithmetics are very easy to be performed.
left shift takes the number and the number of bits that are to be shifted 
It basically performs the bitwise shifts.

Counting the number of set bits is very easy.
I/P n=5
then 101
right shift and perform AND operation.

Count Set bit algorithm can be in this particular algorithm we create the lookup table and then value is fetch using it.
We divide the number into the chucks of 8 numbers.

void initialize(){
    table[0]=0;
    for(int i=1;i<256;i++)
        table[i] = (i&1)+table[i/2]
}

int count(int n)
{
    int res = table[n&0xff]
    n=n>>8;
    res = res+table[n&0xff];
    n=n>>8;
    res=res+table[n&0xff];
    n=n>>8;
    res=res+table[n&0xff];
}
The lookup table is created in an elegant way.
initial 8 bits and is performed the entry is considered. Then shifting is performed.
Same process is followed for the next 8 bits and then other two batches of 8 bits.