Finding the digits of the number there 
are two good ways of doing it we can use the division method.

int countDigit(long n)
{
    int count=0;
    while(n>=0)
    {
        n=n/10;
        ++count;
    }
    return count;
}
Recursive Solution
int countDigits(long n)
{
    if(n==0)
        return 0;
    return 1+countDigits(n/10);
}
Logarathmic Solution
int countDigits(long n)
{
    return floor(log10(n)+1);
}
The complexity in case of the Logarathmic solution is O(1).

There the basic of the mathematics will be used as per our need.

For finding out whether a particular number which is being provided to us is palindrome or not we can use the concept of 
finding the reversal of the number if that reversed number is equal to the actual number then we can say that the number is palindrome
while in the second case the number is not palindrome.

For finding the GCD of a particular number we use the naive solution for that particular. We consider all the number which are smaller then the current number 
if any of the smaller numbers divide the number then we increase the count.
The first recursive call basically swaps the two numbers from one location to another.

LCM of two numbers
I/P: a=4,b=6
OP: 12
This will be finding the least number which will be divisible by both the numbers.
1 is a number which is neither prime and nor composite.

Check whether the number is prime or not. 
if(n==2||n==3) return true;
The number is definitely not prime.
Otherwise we can directly check.
if(n%2==0)
    return 

We can create an algorithm that can help us in fetching the prime numbers.
We can find the factors
The current method we will write most of the base cases that we have if n==1
we return a false value;
n==2 || n==3 return true
n%2==0||n%3 ==0
return false;
Here we are directly omiting all the values which are even and there are many numbers which are the factor of there
Now implement our own solution in which we run a loop O(root(n)) times and incrementation is done i=i+6;
if(n%i==0||n%(i+2)==0)
 returnn false;

We will consider all the prime factors which are within a range.
The naive solution that comes to the mind for finding the divisors of the particular number is 
firstly consider all the numbers 
from i=2 i*i<=n;i++{

}
if(isPrime(i))
{
    int x=i;
    while(n%x==0)
    {
        print x;
        x=x*i;
    }
}
(Will print all the prime factors which are possible.)
The better solution to this particular approach would be finding the first prime factor and t
This solution does not require any extra space. The complexity is root(n)

Seive of erasthanoes is the way for finding whether the number are prime or not.
This algorithm only keeps the number which are actually prime as true while all the other values are marked as false.
(Initially all the indices have the values as true)-> after the algorithm does its work. only elements that have 
We mark the multiples of 2,3,5
We are considering only the prime factors of the current number.

To find the power in the solution we need an elegant way. Uses the power of recursion
if the number is 0 then nothing much to be done.

Bitwise operations are performed on the individual bits itself.
Bitwise AND does the bitwise AND of the two numbers while the Bitwise OR does the bitwise OR of the two numbers.
Bitwise arithmetics are very easy to be performed.
left shift takes the number and the number of bits that are to be shifted 
It basically performs the bitwise shifts.

Counting the number of set bits is very easy.
I/P n=5
then 101
right shift and perform AND operation.

Count Set bit algorithm can be in this particular algorithm we create the lookup table and then value is fetch using it.
We divide the number into the chucks of 8 numbers.

void initialize(){
    table[0]=0;
    for(int i=1;i<256;i++)
        table[i] = (i&1)+table[i/2]
}

int count(int n)
{
    int res = table[n&0xff]
    n=n>>8;
    res = res+table[n&0xff];
    n=n>>8;
    res=res+table[n&0xff];
    n=n>>8;
    res=res+table[n&0xff];
}
The lookup table is created in an elegant way.
initial 8 bits and is performed the entry is considered. Then shifting is performed.
Same process is followed for the next 8 bits and then other two batches of 8 bits.'

Recursive program we will mainly focus on in are the direct recursive programs.
Each recursive program needs to have a base case so that it can terminate.

Recursion is used a lot in many fields of computer science. Both recursive and iterative solutions are 
equivalent in power.
Writing recursive code is easy.
There are many recursive problem.


Depth First search has a recursive solution. 
Tail recursion is the one which is executed faster. In case of the tail recursion the recursive call is at 
the bottom.
While in the other recursion the recursion is not tail recursive.

If there is a tail recursion then the changes are easily made by the tail recursive function. They need to do the recursion there is no auxiliary space required in case of the compiler.

We cannot always simply convert the non tail recursive function to a tail recursive function. The best example for this is merge sort 
There is no non tail recursive function for the merge sort merges after calling the function on the two parts 
Thats why quick sort is preferred over the merge sort as quick sort does not have this particular overhead.

Inorder and Preorder traversal should be preferred rather than the Postorder traversal as the post order traversal goes through the tail recursion.

We need to find the base case for a particular probelm the base case is the one which cannot be split further.
The time complexity of the finding palindrome using a recursive solution is O(n) and the space complexity is O(n)

The generating substrings question can be easily solved using the concept of recursion we can consider to include a particular solution or not.

Tower of Hanoi problem is a very basic problem in case of the computer science which uses an elegant recursive solution for solving the particular problem.

In case of the josepheus problem the 
If there is only one person then that particular person is the only person which will be alive at last.
now the problem has been reduced
(jos(n-1,k)+k)%n This will be solving the problem.

In case of the towerofhanoi problem.
if(N==1)
{
    If there is only one disc present then simply move that particular disk from top to some other location.
    cout<<"move disk 1 from rod"<<"to rod"<<to<<endl;
    return 1;
}

int step1=toh(N-1,from,aux,to);
cout<<"move disk "<<N<<" from rod "<<from<<" to rod"<<to<<endl;
step2=toh(N-1,aux,from,to);

In case of the josephus problem we create the solution to the problem that we currently have.
find the possible series in case of the josephus problem.

In the present josepheus circle problem the counting here in this particular case starts form 1. The first person that is present is numbered as 1.
Create a circle and make the equations according to it.